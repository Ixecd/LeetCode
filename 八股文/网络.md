# 计算机网络常见知识点

## 七层网络模型
**物(物理层)**
- 负责在物理网络中传输数据帧

**数(数据链路层)**
- 负责数据的封帧和差错检测,以及MAC寻址

**网(网络层)**
- 负责数据的路由\转发\分片

**传(传输层)**
- 负责端到端的数据传输

**会(会话层)**
- 负责建立\管理和终止表示层实体之间的通信会话

**表(表示层)**
- 负责把数据转换成兼容另一个系统能够识别的格式

**应(应用层)**
- 负责给应用提供统一接口

## TCP/IP网络模型

*应用层*
- 只专注于为用户提供应用功能,比如HTTP、FTP、DNS、SMTP等
- 应用层是工作在操作系统中的用户态,**传输层及以下工作在内核态**
- 向下传输**应用程序数据**

*传输层*
- 为应用层提供网络支持
- 设计理念是简单、高效、专注,并不负责将数据从一个设备传输到另一个设备上
- 有两个传输协议TCP和UDP
- 传输层数据包超过MSS(TCP最大报文长度),就会分块,每个分块称为一个**TCP段**
- 在应用程序数据头加上**TCP/UDP头**,向下传输**报文**

*网络层*
- 负责实际的传输功能,逻辑上
- 最常使用的是IP协议,IP报文超过MTU(以太网中一般1500字节)就会**分片**
- 对于IPv4协议,IP地址一共32位,共四段,每段是8位
- IP地址有两种意义,需要配合子网掩码
    1. 网络号,标识该ip地址是属于哪个子网的
    2. 主机号,标识同一子网下的不同主机
- 在寻址过程中,先匹配到相同的网络号,找同一子网,之后才会去找对应的主机
- IP的另一个很重要的能力**路由**,两设备之间通常有很多网关/路由器/交换机
- IP中还包括**ICMP**和**ARP**协议
- 路由根据IP给的下一个目的地来选择路径
- 在报文头部加上**IP头**向下传递

*网络接口层*
- 负责为网络层提供**物理链路**传输服务,使用MAC地址这个唯一标识,来识别网络上的设备
- 使用ARP协议来获取对方的MAC地址

# Q&A
## 键入网址到网页显示，期间发生了什么？
1. 浏览器解析URL
2. 根据解析内容生成HTTP请求
3. 查询**服务器域名对应的IP地址**,DNS服务器专门保存了**Web服务器**和**IP**对应关系
4. 委托操作系统(调用socket库)将消息发送给Web服务器,操作系统有协议栈,分为上半部分(TCP/UDP)和下半部分(IP/ICMP/ARP)
5. 通过添加TCP/UDP头部生成报文,传递给IP层
6. IP模块将数据封装成**网络包(IP报文)**发送给通信对象
7. 在网络接口层对IP报文头部添加上MAC头部信息
8. 通过**网卡**将数字信息转化为电信号,控制网卡还需要**网卡驱动程序**
9. **网卡驱动**获取到网络包后,会将其**复制**到网卡内的缓存区中,之后在其**开头加上报头和起始帧分界符,在末尾加上用于检测错误的帧校验序列**
10. 通过**交换机**将网络包**原样**转发到目的地,其工作在MAC层,**交换机的端口不具有MAC地址**,转发端口,到路由器上
11. **路由器**基于IP设计(也有ARP缓存),俗称三层网络设备,各个端口都具有MAC地址和IP地址,之后**丢弃MAC头部**,重新在**路由表**中判断转发目标,找到对应目标,判断目标的**网关**,如果网关是一个IP地址,那这个IP就是要转发的目标地址,表示**还未抵达终点**,继续路由转发(通过ARP获取MAC),如果网关为空,说明已经到达终点
- 注意:子啊网络包传输的过程中,**源IP和目的IP始终不会发生变化,一直变化的是MAC地址**

## HTTP 和 HTTPS 的区别
- HTTP是超文本传输协议,信息是明文传输的,HTTPS就是为了解决HTTP传输过程中的安全问题,在TCP和HTTP应用层之间加入了SSL/TLS安全协议,使得报文能够加密传输
- HTTP连接建立相对简单,TCP三次握手之后就可以进行HTTP的报文传输,而HTTPS除了三次握手之后还需要进行SSL/TLS的握手过程,才可以进行加密报文传输
- HTTP的端口是80,而HTTPS的端口是443
- HTTPS协议需要向CA(证书权威机构)申请数字证书,来保证服务器的身份是可信的

## TCP和UDP的区别和应用场景有哪些
1. TCP是面向连接的传输层协议,传输前需要建立连接,UDP不需要连接,即刻传输数据
2. TCP是一对一的两点服务,UDP支持一对一/一对多/多对多的交互通信
3. TCP传输具有可靠性,数据可以无差错,不丢失,不重复,按序到达,UDP尽最大努力交付,不保证可靠性
4. TCP具有拥塞控制/流量控制机制,来保证传输的安全性,UDP没有
5. TCP首部开销较大最少是20字节,UDP首部只有8字节
6. TCP是面向字节流的传输,没有边界,但保证顺序和可靠,但会出现TCP粘包问题,UDP是一个包一个包发送,有边界,可能丢包/乱序
7. TCP数据段如果大于MSS会在传输层分片,目的主机收到后,也同样在传输层组装,UDP数据包如果大于MTU,会在IP层分片,同样对方在IP层组装
8. TCP和UDP在内核中是两个完全独立的软件模块,所以TCP和UDP可以使用同一个端口
- TCP面向连接,保证可靠性,通常用于 FTP文件传输/HTTP/HTTPS
- UDP面向无连接,不保证可靠性,通常用于包总量较少的通信,DNS/STMP/视频音频等多媒体通信/广播通信

## 什么是SYN攻击?如何避免SYN攻击
- 假设攻击者短时间伪造不同IP地址的SYN报文,服务端每收到一个SYN,就会进入SYN_RECV状态,但是永远不会得到应答ACK,就会**占满服务端的半连接队列**
- 在TCP握手的时候,Linux内核会维护两个队列
    - 半连接队列, SYN队列
    - 全连接队列, accept队列
- 服务端接收到SYN,就会将连接放入SYN队列,之后收到客户端的ACK就会将连接从SYN转到accept中,应用通过accept()socket接口,从accept队列取出连接对象
- 半连接队列和全连接队列都有最大限制,超过限制就默认会丢掉报文
- 避免SYN攻击
    - 建议直接开启 net.ipv4.tcp_syncookies,这样就可以在不适用SYN半连接队列的情况下成功建立连接,绕开SYN
    - 当半连接队列满了之后,再收到SYN不会丢弃,而是计算出一个cookie,将cookie放到第二次握手报文的序列号中,之后如果客户端ACK,服务端会检查ACK包的合法性,如果合法,直接将连接对象放到accpet队列中
    ` echo 1 > /proc/sys/net/ipv4/tcp_syncookies`

## HTTP常见状态码有哪些
- 1xx:提示信息
- 2xx:成功信息
- 3xx:资源重定向
- 4xx:客户端错误
- 5xx:服务端错误

## HTTP常见字段有哪些
- Host: 指定服务器的域名
- Content-Length: 服务器返回数据时,表明本次回应数据的长度
- Connection: 最常用于客户端要求服务器使用HTTP长连接机制,跟 Keep-Alive
- Accept: 客户端请求时,声明自己接受哪些数据格式
- Content-Type:服务器回应时,告诉客户端数据的格式
- Content-Encoding:服务器回应时,数据的压缩方法


## HTTP/1.1、HTTP/2、HTTP/3演变
**HTTP/1.1相比于HTTP/1.0**
1. 使用长连接,改善1.0短链接造成的多次TCP三次握手的性能开销
2. 支持管道网络传输,请求发送出去不必等其回来,就可以继续发送,但是服务器仍然是按照顺序相应的,会出现队头阻塞问题

**HTTP/2.0相比于HTTP/1.1**
1. HTTP/2.0基于HTTPS,安全上有保障
2. 头部压缩,如果发送多个请求,并且头是一样的或者相似的,那么协议会**消除重复部分**
3. 二进制格式,消息头和消息体都是二进制格式,统称为**帧**,可以增加计算机对报文的解析效率
4. 并发传输,HTTP/1.1虽然支持管道传输,但是仍然是同步的方式,会造成队头阻塞问题,HTTP/2引出了Stream概念,多个Stream复用在一条TCP连接上,IO多路复用使用fd来区分,而Stream多路复用使用Stream ID来区分不同的HTTP请求
5. 服务器可以主动推送资源(本质是Hook函数,将StreamID为偶数的自动推送给客户端)
6. 缺陷就是在TCP层的队头阻塞,要等待超时重传

**HTTP/3.0做了哪些优化**
1. 将HTTP下层的TCP协议改成UDP
2. 基于UDP的QUIC协议可以实现类似TCP的可靠性传输
3. QUIC协议的特点有
    - 无队头阻塞
    - 更快的连接建立
    - 连接迁移
4. Stream多路复用中,每个Stream都是独立地,当有一个Stream流发生丢包时,只会阻塞这个流,其他流不会受到影响,不存在队头阻塞问题
5. QUIC协议中直接嵌套了SSL/TLS安全协议,而又不需要TCP三次握手,所以只需要1个RTT(QUIC三次握手,为了确认双方的来连接ID)就可以完成建立连接和密钥协商
6. TCP通过四元组来确定一条TCP连接,当移动设备从5G->WIFI,就会改变IP地址,就会重新建立连接,而QUIC通过**连接ID**来标记通信的两个端点,不管IP是否变化只要连接ID/TLS密钥没有变化,就认为是同一个连接
7. QUIC是基于UDP的伪TCP + TLS + HTTP/2的Stream多路复用协议

## 介绍一下TCP的重传机制
1. TCP实现可靠传输的方式之一就是重传机制,通过序列号与确认应答实现
2. 常见的重传机制有 超时重传/快速重传/SACK/D-SACK
3. 超时重传就是设置一个定时器,如果定时器超时并且没有收到ACK确认应答报文,就会重发数据(超时重传的时间RTO的值应该略大于报文往返RTT的值,是一个动态的值)
4. 快速重传不用定时器,而是以数据来驱动重传,当连续收到三个相同的ACK时,就会触发重发机制.这时候是重发一个还是重传之后所有的
5. SACK,是选择性确认,在TCP头部的选项字段添加SACK,可以将已收到的数据的信息发送给发送方,这样只需要重传丢失的数据
6. D-SACK, 使用SACK来告诉发送方有哪些数据被重复接收了

## 介绍一下TCP的滑动窗口机制
0. 一般说滑动窗口指的都是接收方的
1. 为了解决TCP通信中每发送一个数据,都需要进行一次确认应答,如果数据包的往返时间越长,通信的效率就越低
2. 窗口大小就是指**无需等待确认应答,而可以继续发送数据的最大值**
3. 窗口的实现实际上是操作系统开辟的一个缓冲区,发送方在等到确认应答返回之前,必须在缓冲区中保留已发送的数据,如果按期收到确认应答,此时数据就可以从缓冲区清除
4. 发送数据的过程中,如果有ACK丢失,也可以通过下一个ACK来确认,这个模式就叫**累计确认**或者**累计应答**
5. 窗口的大小一般都是由接收方的窗口大小来确定的
6. TCP滑动窗口是使用三个指针来跟踪数据的,两个指针是绝对指针(一个指向第一个已发送但未收到ACK的字节的序列号,一个是指向未发送但可以发送的第一个字节的序列号),一个指针是相对指针(通过头 + 窗口大小来指向窗口尾部)
7. 窗口大小可能会变为0,会造成死锁现象,所以TCP为每一个连接都设置了一个定时器,只要TCP连接一方收到对方的零窗口通知,就启动持续计时器,如果计时器到时,就会发送**窗口探测报文**
8. 为了避免糊涂窗口综合征,**接收方要满足不通告小窗口给发送方并且开启Nagle算法**

## 介绍一下TCP的流量控制机制
1. 所谓的流量控制机制就是让发送法根据接收方的实际接收能力控制发送的数据量
2. 流量控制是基于滑动窗口的,根据网络情况以及接收方的接收能力来动态的扩展/缩小滑动窗口

## 介绍一下拥塞控制机制
1. TCP不能忽略网络上发生的事情,当网络发生拥塞的时候,TCP就会自我牺牲,降低发送的数据量
2. 目的是避免发送方的数据填满整个网络
3. 拥塞窗口cwnd是发送方维护的一个状态变量,会根据网络的拥塞程度动态变化
4. 如果发生了超时重传,就会认为网络出现了拥塞
5. 控制算法有: 慢启动/拥塞避免/拥塞发生/快速恢复
6. 慢启动:发送方每收到一个ACK,cwnd就会+1,直到涨到慢启动门限ssthresh,指数增长
7. 拥塞避免:当cwnd >= ssthresh的时候,每收到一个ACK,cwnd会增加1/cwnd,线性增长
8. 拥塞发生算法:当出现超时重传时,ssthresh 变为 cwnd / 2, cwnd 会置为 初始值 假设为1
9. 快速恢复:快速重传,收到连续三个相同的ACK,TCP认为网络拥塞不严重, cwnd = cwnd / 2, ssthresh = cwnd;之后才是快速恢复算法,cwnd = ssthresh + 3,重传丢失的数据包,如果还收到重复的包cwnd + 1,如果收到新的数据的ACK
    就把cwnd设置为最开始的ssthresh,直接进入拥塞避免算法